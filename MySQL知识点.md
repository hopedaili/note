## 01 | 基础架构：一条SQL查询语句是如何执行的？

### MySQL逻辑分层（大体）：Server层、存储引擎层

Server层：连接器、查询缓存、分析器、优化器、执行器等，涵盖大多数核心服务功能、所有的内置函数（如日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现（如存储过程、触发器、视图等）。

存储引擎层：负责数据的存储和提取。架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。 

### 查询语句执行流程

```mysql
mysql> select * from T where ID=10；
```

#### 1.连接器

- 连接器负责跟客户端建立连接、获取权限、维持和管理连接 。

- 修改权限后重新登陆才生效。

- 客户端长时间没动静，连接器自动断开连接，参数由wait_timeout控制，默认8小时。

- 长连接：连接成功后，如果客户端持续有请求，则一直使用同一个连接。

- 短连接：每次执行完很少的几次查询就断开连接，下次查询再重新建立连接。

- 尽量使用长连接

全部使用长连接有些时候MySQL占用内存涨得快，会被系统杀掉，异常重启，解决方案？

1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 
2. 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 

#### 2.查询缓存

- 之前执行过得语句以key-value形式缓存在内存中，key是查询语句，value是查询结果。
- 大多数情况不用查询缓存，弊大于利。（更新操作会清空表上所有查询缓存，命中率低，失效频繁，将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存 ）
- MySQL 8.0 版本直接将查询缓存的整块功能删掉了 

#### 3.分析器

- 一般语法错误会提示第一个出现错误的位置，紧接“use near”的内容。 

#### 4.优化器

- 表里有多个索引得时候，决定用哪个索引；或者语句有多表关联得时候，决定连接顺序

#### 5.执行器

- 判断权限，然后执行或者报错

## 02 | 日志系统：一条SQL更新语句是如何执行的？

日志模块：redo log（重做日志）和binlog（归档日志）

### redo log

#### WAL技术：
全称是Write-Ahead Logging，关键点在于险些日志，再写磁盘。
#### 更新操作：
InnoDB引擎会先把记录写到redo log里，并更新内存，这时候更新就算完成了。同时，InnoDB引擎会在适当的时候将这个操作记录更新到磁盘里面，这个更新往往是在系统比较空闲的时候做。

#### redo log 擦除：

InnoDB的redo log大小固定，从头开始写，写到末尾又回到开头循环写。write pos 是当前记录的位置，一边写一边后移。checkpoing是当前要擦除的位置们也是往后推移并且循环的，擦除记录钱要把记录更新到数据文件。写满后不能执行更新，得停下来先擦掉一些记录，把checkpoint推进一下。

### binlog：















































































































